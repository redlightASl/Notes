# RISC-V扩展指令子集

RISC-V具有很高的可扩展性，既预留出了指令编码空间，也提供了预定义的Custom指令

RISC-V的标准指令集仅使用了少部分指令编码空间，更多的指令编码空间被预留给用户进行扩展指令

用户可向自己的RISC-V内核中加入16位宽和32位宽的不同指令，每个指令的编码空间除了用于寄存器操作数的索引外，还剩余众多位的编码空间，这些未定义的编码空间可以通过自定义指令加以利用，这也就让RISC-V灵活性得到了很大提高，为FPGA实现软核与挂载附加硬件加速电路提供方便。总体上来说用户可使用的编码空间有三类：

* 没有使用的编码空间
* 没有实现指令类型的编码空间
* 未定义的指令类型组

除此之外，RISC-V架构在32位指令中预定义了4组Custom指令类型，每种Custom均有自己的Opcode，用户可利用这四种指令类型扩展成为自定义的协处理器指令，蜂鸟E203也使用了Custom指令类型来扩展协处理器指令

# 蜂鸟E203自带协处理器

蜂鸟E203中应用了所谓DSA**专用领域架构**的设计理念，映入了预定义的Custom指令和协处理器接口EAI

> 芯来官方推荐用户使用EAI接口在附带SoC之外挂载自定义的外部模块——来自芯来集创赛官方讲解视频

蜂鸟E203借鉴了开源RISC-V处理器Rocket Core的协处理器接口RoCC，为了与原始接口进行区分，命名为**EAI（Extension Accelerator Interface）接口**

所以使用Custom指令在蜂鸟E203上也可以称为EAI指令

## EAI指令

### 编码

32位的EAI指令编码格式如下表所示

| 31-25  | 24-20 | 19-15 | 14   | 13   | 12   | 11-7 | 6-0    |
| ------ | ----- | ----- | ---- | ---- | ---- | ---- | ------ |
| funct7 | rs2   | rs1   | xd   | xs1  | xs2  | rd   | opcode |
| 7'b    | 5'b   | 5'b   | 1'b  | 1'b  | 1'b  | 5'b  | 7'b    |

* opcode段

  使用RISC-V架构中定义的Custom-1到4的指令组

* xs1、xs2、xd比特位

  用于控制是否需要读源寄存器rs1、rs2和写目标寄存器rd

  如果xs1=1，表示该指令需要读取rs1比特位索引的通用寄存器作为源操作数1；如果xs1=0，则表示不需要源操作数1

  如果xs2=1，表示该指令需要读取rs2比特位索引的通用寄存器作为源操作数2；如果xs2=0，则表示不需要源操作数2

  如果xd=1，表示该指令需要写回结果到rd比特位指示的目标寄存器；如果xd=0，则表示不需要写回结果

* funct7区间

  可用作额外的编码空间，用于编码更多的指令

  一种Custom指令组可以使用这一区间编码出128条指令，四组Custom指令则可以编码出512条*两读一写*指令

### 接口信号

EAI接口主要包含4个通道

1. 请求通道：用于主处理器在EXU级将指令信息和源操作数派发给协处理器
2. 反馈通道：用于协处理器反馈主处理器告知其已经完成了该指令，并将结果写回主处理器
3. 存储器请求通道：主要用于协处理器向主处理器发起存储器读写请求
4. 存储器反馈通道：主要用于主处理器向协处理器返回存储器读取结果

## 协处理器接口

EAI协处理器在蜂鸟E203流水线中处于和LSU同级位置，如果需要写回操作则还会占据写回操作对应的流水线位置

整个EAI协处理器的使用非常灵活，可以根据需求随时修改

### EAI流水线接口

EAI指令流程如下：

1. 主处理器译码单元在EXU级队指令的Opcode进行译码，判断其是否属于任意一种Custom指令组

2. 判断指令属于Custom指令组后，再根据指令编码的xs1和xs2位判断是否需要读取源寄存器，如需读取则在EXU级立即读取通用寄存器组并取出源操作数

3. 如果当前读取的源寄存器与其他指令存在RAW先读后写依赖性，则暂停流水线直至该RAW解除；主处理器还会根据指令编码的xd位判断是否需要将结果写回通用寄存器组

4. 如果需要写回，则将目标寄存器的索引信息存储在主处理器的流水线控制模块中直到写回完成，以供后序指令进行数据依赖性判断

5. 完成以上步骤后，主处理器在EXU级通过EAI接口的请求通道派发以下内容给协处理器电路：

   * 指令编码信息
   * 两个源操作数rs1、rs2的值（均为32位宽）
   * 指令的派发标号（Dispatch ITag）——这个派发标号主要用于追踪指令的派发顺序，**协处理器收取到ITag后应当携带该ITag直至写回结果，并将ITag连同结果一并返还给主处理器**

6. 协处理器接收到指令后，进一步对指令进行译码并执行既定操作（从点亮LED到连接WiFi，只要电路能实现就能通过主处理器控制）。协处理器可以单拍或多拍返回结果，**对于多拍后返回结果的指令，可以是阻塞式的也可以是流水线式的**

7. 协处理器和主处理器之间的请求通道采用Valid-Ready方式的同步握手接口，只要协处理器能够接受指令，就可以将Ready信号拉高。只要协处理器能够先后连续接受多条指令，主处理器就可以先后连续发送多条指令到协处理器

8. 协处理器完成执行后，通过EAI接口的反馈通道将结果反馈给主处理器。**如果协处理器接收并执行了多条指令，需要保证其在Response Channel反馈结果的顺序与其在请求通道接受指令时一致**（**按序写回**）

9. 反馈通道需要包括指令的ITag并遵循其顺序，如果是需要写回结果的指令，则反馈通道还要包含返回结果的值

10. 主处理器在收到反馈通道的反馈结果后，将此指令从流水线中退出并将结果写回寄存器组（如果有写回需求）

    Custom指令被派发到协处理器到协处理器反馈结果并退役之间的这段时间称为**滞外时间**

蜂鸟E203最多能支持不超过4条以上的滞外指令，**如果协处理器是流水线执行的方式，但其需要超过4个周期以上才能反馈结果，那么流水线会出现空泡**

### EAI存储器接口

在处理器的LSU中为EAI协处理器预留了专用的访问接口，协处理器能够访问主处理器能够寻址的数据存储器资源（包括ITCM、DTCM、系统存储总线、系统设备总线、快速IO接口等）

EAI指令访问存储器资源的实现机制如下所示

* 专用访问通道基于ICB总线标准

* 协处理器在接收到EAI的请求通道发送过来的指令后立即译码，如果发现需要访问存储器，则立即将存储器独占信号拉高，主处理器将会阻止后续的指令继续访问存储器资源

* 协处理器访问存储器需要**通过ICB的存储器请求通道向主处理器的LSU发起请求，LSU在完成存储器读写操作后通过ICB的存储器反馈通道向协处理器反馈**。

  * 读操作

    对主处理器进行32位对齐的一次读操作，返回读取的数据和本次读操作是否发生了错误

  * 写操作

    通过存储器请求通道中的写数据和字节掩码控制写操作的数据和粒度，返回本次写操作是否发生了错误

* 协处理器和主处理器LSU接口的ICB总线野草去Valid-Ready方式进行同步握手，**协处理器完成访存后需要将存储器独占信号拉低，主处理器将会释放LSU允许后续指令继续访问存储器资源**

## 协处理器应用

这里以独立的PID硬件加速模块作为协处理器挂载到EAI接口

本模块需要从通用寄存器输入三个参数$K_P,K_I,K_D$数据作为PID基础参数，从主处理器寄存器组中获取复位rst_n和PID的目标参数$TARGET$两个控制信号，时钟信号则由内核时钟一并提供；模块将自动根据TARGET参数输出合适的比较值给PWM模块，PWM模块直接通过FPGA的MIO对外输出PWM信号控制电机

### 定义协处理器指令

在这里定义了8个协处理器控制指令：

* PID_SET_KP

  **设置PID初始参数K~P~**

  Opcode指明使用Custom0指令组

  xd=0，xs1=1，xs2=0，funct7=7'b0000001，在硬件加速模块中定义7'b0000001为设置参数指令

  从rs1中读取K~P~值

* PID_SET_KI

  **设置PID初始参数K~D~**

  Opcode指明使用Custom0指令组

  xd=0，xs1=1，xs2=0，funct7=7'b0000001，在硬件加速模块中定义7'b0000010为设置参数指令

  从rs1中读取K~I~值

* PID_SET_KD

  **设置PID初始参数K~D~**

  Opcode指明使用Custom0指令组

  xd=0，xs1=1，xs2=0，funct7=7'b0000001，在硬件加速模块中定义7'b0000011为设置参数指令

  从rs1中读取K~D~值

* PID_SET_TARGET

  **设置PID目标参数**

  Opcode指明使用Custom0指令组

  xd=0，xs1=1，xs2=0，funct7=7'b0000010，在硬件加速模块中定义7'b0000100为设置目标指令

  从rs1中读取TARGET值

* PID_ENABLE

  **开启PID**

  Opcode指明使用Custom0指令组

  xd=0，xs1=0，xs2=0，funct7=7'b0000000，在硬件加速模块中定义7'b0000000为开启信号

  接收到开启信号后，PID模块会自动使用之前设置的值来计算PID趋近目标并输出到PWM模块

* PID_DISABLE

  **关闭PID**

  Opcode指明使用Custom0指令组

  xd=0，xs1=0，xs2=0，funct7=7'b1111111，在硬件加速模块中定义7'b1111111为关闭信号

* PID_RESET

  **复位PID**

  Opcode指明使用Custom0指令组

  xd=0，xs1=0，xs2=0，funct7=7'b1111111，在硬件加速模块中定义7'b1111111为关闭信号

### 协处理器实现

*这部分内容是笔者参加比赛使用，预计等比赛完后会在其他博文里给出*

### 协处理器指令处理时间分析

* PID_SET_XXX

  四个指令都是负责向协处理器的”外设控制寄存器“中填充数据，只需要1个时钟周期即可完成

* PID_ENABLE/DISABLE/RESET

  这三个指令向协处理器发送控制指令，协处理器的译码只需要1个时钟周期即可完成

完成设置并开启PID后，协处理器将会自动根据写入的TARGET值控制PWM输出，无需主处理器继续接管

当任务执行到一半但CPU继续发出指令时，协处理器应立即自动复位并根据更新的参数或指令进行操作

整个协处理器的设计思路就是“快速”，因为实时系统中往往需要更高的响应速度，将协处理器的操作时间设置为1个时钟周期且不加入写回的操作可以让CPU专心执行例行任务，在遇到中断时不必担心打断PID运行
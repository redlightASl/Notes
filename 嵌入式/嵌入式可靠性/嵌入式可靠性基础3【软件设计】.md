# 嵌入式可靠性基础3【软件设计】

这一节主要介绍嵌入式软件的可靠性设计规范。

长话短说，嵌入式软件以控制功能为主，软件架构呈扁平层次：底层是寄存器接口或有硬件驱动层（寄存器抽象库或HAL库）进行抽象；中间层是硬件控制逻辑，PID、控制滤波等控制算法会在这一层得到实现；顶层则是数字信号处理DSP、图像信号处理ISP等信号处理算法和设备整体驱动程序（主任务逻辑）。

相对于桌面端乃至服务器端的应用，嵌入式程序各层级之间的耦合更加紧密，经常会出现顶层绕过中间层直接调用底层驱动的情况（尤其是裸机程序和机器人控制程序中），程序与硬件的结合也更紧密，因此对于响应速度、安全性和可靠性的要求大大高于性能要求。

同时还应该考虑到软件改进过程中既能改掉bug，又能不引入新bug，这就意味着“能跑就行”对于高可靠性嵌入式程序而言是远远不够的。

总的来说，对各种嵌入式软件可靠性判定标准是：**具有判错、防错、纠错、容错四大功能，并且要有对测控部分和人机接口的单一故障（Single Fault Condition，SFC）要有错误处理功能**

## 嵌入式软件系统设计

嵌入式软件系统也是软件系统，在进行系统分析时，要牢记软件系统固有的那些性质：

* **复杂性**（complexity）：软件要增加规模不仅仅是简单地增加相同内容的规模，还要增加新的内容，这就使得随着软件规模的增加其复杂度的增加是非线性的，整体复杂性的增加可能比线性增加要大得多。

    软件复杂性是软件工程的基本前提，它它会给软件项目组里的组员之间交流带来困难，从而导致产品的瑕疵、开支过多和时间耽搁；给我们穷举所有软件可能的状态带来了不少的困难，进而导致软件最后的不可靠性；各个功能模块之间的调用关系也会随着软件的复杂度的增加而变得复杂，这使得项目变得很难去使用；复杂的软件结构同样会使得软件的扩展性和安全性受到影响

    软件的复杂性和硬件的复杂性有关联之处但不完全相同：*硬件复杂性是由物理规则带来的；而软件复杂性是由人（一般是用户，但也可能是产品经理）的需求带来的*

* **整合性**（conformity）：一个软件往往是由不同的人一起开发出来的

    为了完成不同子系统的整合，就要求软件开发者不得不设计出接口规范和符合规范的软件，这个困难往往随着时间变化，甚至随着不同的应用场合而变化。在嵌入式设备上进行的软件开发还必须与硬件开发对接，因此软件-硬件接口规范（ISA、Reg-map）就成为必要

* **可变性**（changeability）：软件相对于硬件要更容易修改，而且修改的频率要比硬件大得多

    有些用户就是喜欢去试探那些超出软件工作域的情形，软件开发者设计的软件必须要能够面对这些挑战而不崩溃，但这是一个不可能在一开始全部知道的，所以软件更新是软件发布后的“家常饭”。在硬件设计中也要为软件的升级预留出接口；而软件升级时要求保障外部硬件设备全部处于静默或受控情况 

* **不可见性**（invisibility）：软件不同于其它设计，软件没有空间性，所以具有不可见性的特点

    软件工作者可以用有向图来表示出控制流、数据流、模式的依赖、时间序列、命名空间的关系，但是软件开发还是存在内在的不可见性，这都将成为阻碍软件设计和各个软件工作者交流的“拦路虎”。这不同于传统的硬件开发

随着现代软件技术的发展，已经有越来越多方便的工具能辅助软件设计：**高级语言**（在嵌入式领域，基本可以视为C/C++，以后也许会加入Rust、Go乃至Python）让所有软件开发者不用再去直接与CPU交互；**硬件抽象层**（Hardware Abstract Layer，HAL）让嵌入式开发者不用再和外设寄存器打交道，原厂也都提供了方便易用的**SDK**（即使没有这样的SDK，开发者也已经可以照抄ST、TI的代码自己实现一份青春版）；芯片性能的提高让32位单片机上运行**实时操作系统**（RTOS）或是一个简单的自制内核成为可能；Github上的**开源**代码和软件库已经实现了大部分常用功能，软件开发者只需要把它们稍微修改移植到本地即可；LLM是更新的技术，它已经能够很好地辅助人工编码，谁都离不开Copilot或是ChatGPT了（😀）

但这些技术真的能够彻底让嵌入式开发者从硬件系统和软件工程的泥淖中解脱吗？

正如弗雷德里克·布鲁克斯所说：**软件工程没有银弹**。

软件系统设计和硬件设计一样，没有捷径。高级语言只能是带来一种新的软件设计的技术，并不能从根源上解决软件四大问题，嵌入式软件面对的屎山只是从原来几千行汇编变成了现在的几万行C代码；基于面向对象理念设计的硬件抽象层是硬件开发者的帮手，但它本身过于臃肿，在与硬件深度耦合的高实时性、成本优化设计中反而会拖后腿。同理，原厂的SDK和好用的图形配置工具结合能够让一个新手直接忽略艰深的硬件部分，专注于软件逻辑，但很明显并不能逃开可变性和整合性的桎梏；人工智能是个潜力很大的例外——LLM的变化已经超越了当年软件专家的预期，但目前来讲由AI设计一整套软件系统所需要的时间和算力成本还是太高，大模型是否具有媲美资深程序员的创造力还是有待检验

互联网行业将敏捷开发视为部分的银弹，这确实能够在成本时间限制下达到要求完善和快速成型（Requirements refinement and rapid prototyping），但嵌入式软件中的敏捷开发受到硬件系统的限制——如果硬件不能快速迭代、交付，软件更迭只能作为“亡羊补牢”的手段

因此，**开发者**还是嵌入式软件设计中的主体，也是达到嵌入式软件设计可靠性的保障





## 软件冗余设计









## 软件鲁棒性设计















## 一般设计要求










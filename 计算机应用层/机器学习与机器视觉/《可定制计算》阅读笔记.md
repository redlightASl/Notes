# 《可定制计算》阅读笔记

本笔记以基础概念为线索编写，黑体部分是关键字

* **登纳德缩放定律**：晶体管在满足内电场恒定（即每代芯片的供电电压降低30%）条件下，晶体管尺寸每代（约两年）减少30%。

    结合该定律和摩尔定律可得推论：晶体管密度每代翻倍，同时晶体管延时降低30%，功耗降低50%，能耗降低65%

    换句话说，同面积下能集成晶体管的数目翻倍，带来功耗和频率的翻倍，就好像同面积的电路被缩放到原来的1/4

    但是到21世纪早期，由于量子效应，晶体管漏电功耗显著增加，登纳德定律逐渐失效

* **定制计算**：调整处理器结构以使其适应于某种特定应用领域的技术

    面对登纳德缩放定律失效、摩尔定律放缓，定制计算技术成为提高计算效率的关键技术之一
    
    往往可重构的定制计算电路可以使得能效得到1~2个数量级提升；而专用于某个领域的定制计算电路有时能够实现数百万倍的能效提升；同时引入*可重构性*并利用*可整合*的硬件加速其可以解决适用范围过窄的问题，现在常见的DSA（异构计算）就是这个思路的延伸
    
* **暗硅**：在多核cpu中并不是所有核心都会被使用，往往同时工作的只有其中小部分核心，其他核心因为功耗、发热等问题往往得不到应用，这部分电路被称为暗硅

* **通用片上多处理器**（Chip MultProcessor，CMP）：具有通用性的计算处理器，常见的CPU，如i9 11900k、r5 5600x等具有多核心的桌面级cpu都属于这个类型

* **可定制异构平台**（Customizable Heterogeneous Platform，CHP）：用于提供定制化计算服务的可定制的SoC

    一般CHP中包含四个部件：

    * 用于通用计算和控制逻辑的**处理器核**
    * 用于定制计算的硬件**加速器**
    * 用于辅助计算和低功耗控制的**协处理器**
    * 存储数据和程序的**片上存储部件**

* **可重构硬件**：流片之后依然可以被灵活调整的硬件

    硬件可以被重构的程度取决于重构的粒度，越小的重构粒度灵活性越大，但一般会造成性能下降和能效降低等额外开销

    传统的可重构硬件只有FPGA一种，它算作可细粒度重构的硬件，因此会比同算法的ASIC实现有更低的速率和更高的开销

* **专用加速器**：针对特定领域内有限的一组应用或算法进行优化的硬件

    早期的GPU、图像数据编解码器、加解密加速器等都属于加速器

* **动态处理器核缩放和去特征化**：选择性停用处理器核中的部件来节省能耗

    通用的做法是在内核中引入特定机器的寄存器，用来指示特定部件是否激活

    stm32f4的dsp和fpu就使用了这样的技术

* **处理器核融合**：使一个大核能够像真正的许多小核叠加工作一样的体系结构，可以动态适应不同数量的线程级或指令级的并行处理

    通过将处理器核拆成两部分实现：一个是窄发射宽度的常规处理器核，但是它的取指模块（Fetch Module）会被舍弃；另一部分是充当模块化的取指/译码/派发模块的额外部件，负责为每个处理器核心执行取指指令，或统一为多个处理器核提供指令。取指模块会使用宽读取引擎读取整个指令块并将它们分发给各个核心，流水线结束后，通过一个排序流水线步骤来让指令顺序写回

* **定制指令集扩展**：用特定工作负载中的新指令来让处理器快速分派任务到计算模块

    intel的AVX-512指令集就是这样增强CPU性能的（可惜并不怎么实用）

    商用处理器常使用的就是像SSE和AVX这种专用*向量指令*形式，允许简单的指令操作大量数据。现代高性能处理器一般都采用超标量架构，它能够实现指令集层面的并行化处理，利用的是**单指令多数据流**（SIMD）指令，也就是所谓的向量指令。为了通过一个指令控制多个数据的处理，需要引入一组新的寄存器和一组用于执行向量并行计算的ALU。x86指令集中，向量指令在4~16个元素的小向量上运行，主要用于执行浮点运算。超标量处理器还引入了基于通道的设计：多个小型计算引擎和寄存器元素并行参与计算，发出一条向量指令，所有通道都会接收该指令，因此可以并行化地执行大量重复计算的任务

    定制扩展指令集还可以通过*定制计算引擎*实现——一般的ALU只有乘法、加法、移位等功能，但是可以通过改变流水线的方式塞进乘除法器乃至专用的矩阵点乘叉乘电路

    *可重构指令集*也是其中一个解决方案，它允许程序编写自己的指令，但是往往需要编译器对定制指令支持才可行

* **松耦合加速器**：独立于处理器内核运行的粗粒度加速器，是与核心交互但是不固定在核上的粗粒度计算引擎，简称LCA

    LCA可以部署在片上或片外，PC上的cpu+显卡组合就是一个广义上的LCA架构；片上LCA没有物理邻接某个特定核心，但是可以被系统中所有核心共享，LCA通过一个简单快速的控制逻辑电路（最常见的就是DMA）拉控制数据输入输出。但是LCA只能使用ASIC方式实现，这就导致LCA必须具有以下特性：1. 算法足够成熟；2. 算法需要算力较大或比较重要。DPU、APU等针对AIoT领域的SoC就可以理解成采用了LCA架构

    多核共享的LCA需要加入仲裁开销，一般存在软件和硬件两种仲裁方法。

    特别地，LCA不依赖编译器，而依赖开放给开发者的API，比如OpenCL就是一种面向通用计算的API架构；而Cuda-C++是NVidia开发的针对自家GPU的API接口；其他的硬件加速设备也会有针对性的接口，最大的阻碍就是它们往往不兼容

    LCA最大的缺点不在于因为不耦合于内核，往往存在较大延时；而在于只能使用ASIC形式实现，导致它的功能固定。

    IBM推出的线速处理器（WSP）就是一种含有LCA的处理器

* **现场可编程硬件**：为通用性牺牲一些效率和性能的超细粒度可重构电路

    使用FPGA可以实现类似LCA的功能，但它们往往更加灵活，但相对应的性能和效率有所损失。因为HLS技术的成熟，现在FPGA硬件加速的开发变得相对快捷不少。Zynq平台上的高带宽硬件加速也是当前发展方向之一

* **粗粒度可重构阵列**：具有接近ASIC性能和具有一定可重构性的组合加速器，也就是CGRA组合加速器

    它试图中和LCA和FPGA，通过一组粗粒度部件及其互联机制，能够使得CGRA在可编程的基础上实现接近LCA的效率和开销。从概念上说，CGRA是含有小型加速器，而不是LUT（查找表）的FPGA

    许多CGRA的工作聚焦于资源的*静态映射*：计算单元之间的互联通信通过离线计算完成，或作为编译过程的一部分，这样可以尽可能提高运行效率；同时CGRA还具有硬件加速器资源虚拟化的特点——在编写程序时可以直接使用高级语言，编译器负责将其直接映射到具体器件的连接。从程序映射的角度，CGRA是一个全连接的计算引擎集，将计算映射到这样的一个体系架构上非常简单

    不过这也使得它难以用Cuda或Verilog的思路编程——电路是不能修改的，开发者只能通过配置CGRA中加速引擎的互联逻辑实现编程；反过来讲，它可以高效实现算法加速，并且由于组成加速器的部件较少，这些部件到硬件按资源的映射过成也相对容易，更可贵的是内部空间利用率达到较高的程度。*动态映射*可以在运算时实现较高的效率——计算引擎根据需要实现的算法动态更改计算模块之间的连接拓扑，这是基于CGRA具有*全连接特性*

    > CGRA计算架构通过空域硬件结构组织不同粒度和不同功能的计算资源，通过硬件运行时配置，调整硬件功能，根据数据流的特点，让功能配置好的硬件资源互连形成相对固定的计算通路，从而以接近“专用电路”的方式进行数据驱动下的计算
    >
    > CGRA的全连接特性是指计算模块可以在任意邻接模块之间建立动态连接

    CGRA的实现还处在起步阶段，现在的开发主要依靠实验室，主要原因在于比起FPGA，CGRA更加依赖生态和编译器。目前一个典型的CGRA架构被称为CHARM，它使用一种称为加速器块设计（ABC）的硬件资源管理机制，它管理一些小的计算模块，被称为ABB（加速器构建模块），ABB以类似FPGA的岛形分布在片上，每个岛内部包含DMA、便签式存储器SPM、实现岛内互联的内部网络和实现岛间通信的网络接口。传统核心通过将描述ABB非循环通信图的配置写入普通共享内存中以调用加速器，然后ABC会根据ABB图最大限度提高新实例化的加速器性能，并为每个参与的ABB分配一些任务。为了进一步提升性能，ABB会继续调度加速器的其他实例直到资源用完或任务完成

* **高速缓存**：现代处理器中往往使用高速缓存（cache）来降低数据访问延时，并通过数据重用提高系统存储带宽。具有较高空间/时间局部性的数据块可以保存在高速缓存中，它通常使用硬件自动管理。高速缓存主要由两个块构成：*标签阵列*和*数据阵列*。

    标签阵列用于检查请求的数据块是否位于数据阵列中，数据阵列用于存储具体数据。

* **便签式存储器**：由软件管理的缓冲区（buffer），缓冲区是指能够使用硬件或软件进行管理的FIFO、堆栈或RAM组

    便签式存储器具有高速缓存不具有的以下优势：

    * *可编程性*：方便软件开发者使用，可以作为处理器核的近存储器（near memory）进行软件编程；也可作为专用处理器核或者硬件加速器的近存储器，使得程序员不需要担心底层的管理策略（由硬件状态机完成），只需要通过软件进行性能优化就可以提供更高自由度的缓冲区管理策略
    * 可预测的访问延迟：由于高速缓存块是由通用的替换策略管理的，因此高速缓存的访问延迟很难预测，以至于经常出现`cache miss`的情况；但是便签式存储器可以保证在编译器优化下实现优化的数据重用来避免下一级存储器访问造成的性能下降
    * 低功耗、小面积：高速缓存所使用的标签阵列和比较逻辑电路往往需要更大的面积；但便签式存储器只需要一个状态机进行控制，因此它能够减小使用的面积并减小动态功耗

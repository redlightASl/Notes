#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# generated by LLM
import os
import re
from pathlib import Path

def should_skip_directory(dir_name):
    """Determine if a directory should be skipped"""
    skip_dirs = {
        'tools', '.vscode', '.git', 'node_modules', 'book', 
        '__pycache__', '.pytest_cache', 'dist', 'build'
    }
    return dir_name.startswith('.') or dir_name in skip_dirs

def escape_markdown_title(title):
    """Escaping special characters in markdown titles"""
    if not title:
        return "未命名"
    
    title = str(title).strip()
    title = title.replace('[', '').replace(']', '')
    title = title.replace('(', '').replace(')', '')
    title = title.replace('\\', '').replace('/', '-')
    title = title.replace('|', '-').replace('*', '')
    
    if not title.strip():
        return "未命名"
    return title.strip()

def get_title_from_md(file_path):
    """Extracting headings from markdown files"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            match = re.search(r'^#\s+(.+)$', content, re.MULTILINE)
            if match:
                title = match.group(1).strip()
                return escape_markdown_title(title)
            return escape_markdown_title(file_path.stem)
    except Exception as e:
        print(f"读取文件{file_path}时出错: {e}")
        return escape_markdown_title(file_path.stem)

def normalize_path(file_path):
    """Standardized file path"""
    path_str = file_path.as_posix()
    path_str = re.sub(r'\s+', '', path_str.replace(' .md', '.md'))
    return path_str

def is_valid_markdown_link(title, path):
    """Verify that the markdown link works"""
    if not title or not path:
        return False
    if '[' in title or ']' in title or '(' in title or ')' in title:
        return False
    if not path.endswith('.md'):
        return False
    if ' .md' in path or '  ' in path:
        return False
    return True

def collect_files_in_directory(dir_path):
    """Collect all markdown files in the directory"""
    files = []
    readme_file = None
    
    if not dir_path.exists():
        return files, readme_file
    
    for file_path in dir_path.iterdir():
        if file_path.is_file() and file_path.suffix == '.md':
            if file_path.name.lower() == 'readme.md':
                readme_file = file_path
            else:
                files.append(file_path)
    
    return sorted(files, key=lambda x: x.name), readme_file

def collect_subdirectories(dir_path):
    """Collect all subdirectories in the directory"""
    subdirs = []
    
    if not dir_path.exists():
        return subdirs
    
    for subdir in dir_path.iterdir():
        if subdir.is_dir() and not should_skip_directory(subdir.name):
            subdirs.append(subdir)
    
    return sorted(subdirs, key=lambda x: x.name)

def create_logical_groups(dir_path, md_files):
    """Creating logical groupings for specific directories"""
    groups = {}
    ungrouped = []
    
    # ARM目录的特殊分组逻辑
    if "ARM" in str(dir_path):
        arm_notes = []
        cortex_notes = []
        
        for file in md_files:
            filename = file.name
            if filename.startswith("ARM内核学习"):
                arm_notes.append(file)
            elif filename.startswith("Cortex-M0解读"):
                cortex_notes.append(file)
            else:
                ungrouped.append(file)
        
        if arm_notes:
            groups["ARM笔记"] = sorted(arm_notes, key=lambda x: x.name)
        if cortex_notes:
            groups["Cortex-M0解读"] = sorted(cortex_notes, key=lambda x: x.name)
    
    # 机器学习与机器视觉目录的分组
    elif "机器学习与机器视觉" in str(dir_path):
        vision_3d = []
        
        for file in md_files:
            filename = file.name
            if "三维重建" in filename:
                vision_3d.append(file)
            else:
                ungrouped.append(file)
        
        if vision_3d:
            groups["三维重建"] = sorted(vision_3d, key=lambda x: x.name)
    
    # 一生一芯目录的分组
    elif "一生一芯" in str(dir_path):
        arch_notes = []
        superscalar_notes = []
        
        for file in md_files:
            filename = file.name
            if filename.startswith("计算机体系结构"):
                arch_notes.append(file)
            elif filename.startswith("超标量处理器"):
                superscalar_notes.append(file)
            else:
                ungrouped.append(file)
        
        if arch_notes:
            groups["计算机体系结构"] = sorted(arch_notes, key=lambda x: x.name)
        if superscalar_notes:
            groups["超标量处理器设计"] = sorted(superscalar_notes, key=lambda x: x.name)
    
    else:
        ungrouped = md_files
    
    return groups, ungrouped

def add_directory_section(dir_path, summary_content, indent_level=0):
    """Add catalog section"""
    if not dir_path.exists():
        return
    
    indent = "  " * indent_level
    dir_title = escape_markdown_title(dir_path.name)
    
    # 收集当前目录的文件和子目录
    md_files, readme_file = collect_files_in_directory(dir_path)
    subdirs = collect_subdirectories(dir_path)
    
    # 如果目录下没有任何markdown文件和子目录，跳过
    if not md_files and not readme_file and not subdirs:
        return
    
    # 添加目录标题 - 必须是链接格式
    directory_added = False
    remaining_files = md_files.copy()
    
    if readme_file:
        readme_path = normalize_path(readme_file)
        if is_valid_markdown_link(dir_title, readme_path):
            summary_content.append(f"{indent}- [{dir_title}](./{readme_path})")
            directory_added = True
    elif md_files:
        # 如果没有README，使用第一个md文件作为目录链接
        first_file = md_files[0]
        first_file_path = normalize_path(first_file)
        if is_valid_markdown_link(dir_title, first_file_path):
            summary_content.append(f"{indent}- [{dir_title}](./{first_file_path})")
            remaining_files = md_files[1:]
            directory_added = True
    elif subdirs:
        # 如果只有子目录没有文件，创建一个空链接
        summary_content.append(f"{indent}- [{dir_title}]()")
        directory_added = True
    
    if not directory_added:
        return
    
    # 创建逻辑分组
    groups, ungrouped_files = create_logical_groups(dir_path, remaining_files)
    
    # 添加分组内容
    file_indent = "  " * (indent_level + 1)
    group_indent = "  " * (indent_level + 1)
    
    # 先添加未分组的文件
    for md_file in ungrouped_files:
        title = get_title_from_md(md_file)
        file_path = normalize_path(md_file)
        
        if is_valid_markdown_link(title, file_path):
            summary_content.append(f"{file_indent}- [{title}](./{file_path})")
    
    # 添加分组
    for group_name, group_files in groups.items():
        summary_content.append(f"{group_indent}- [{group_name}]()")
        for md_file in group_files:
            title = get_title_from_md(md_file)
            file_path = normalize_path(md_file)
            
            if is_valid_markdown_link(title, file_path):
                summary_content.append(f"{file_indent}  - [{title}](./{file_path})")
    
    # 递归处理子目录
    for subdir in subdirs:
        add_directory_section(subdir, summary_content, indent_level + 1)

def generate_summary():
    """generate SUMMARY.md"""
    summary_content = []
    
    # 添加固定头部
    summary_content.extend([
        "# Notes",
        "",
        "[介绍](./README.md)",
        "[Introduction](./README_en.md)", 
        "[License](./LICENSE)",
        "",
        "---",
        ""
    ])
    
    # 定义主要目录结构（按SUMMARY_bak.md的完整顺序）
    main_directories = [
        "计算机底层",
        "计算机应用层", 
        "IC与FPGA",
        "嵌入式",
        "学校课程笔记",
        "工程记录",
        "杂项",
        "马哲"
    ]
    
    root_path = Path('.')
    
    # 处理每个主要目录 - 不再添加# 标题，直接处理目录
    for dir_name in main_directories:
        dir_path = root_path / dir_name
        if dir_path.exists():
            print(f"处理目录: {dir_name}")
            add_directory_section(dir_path, summary_content, 0)
            summary_content.append("")  # 添加空行分隔
        else:
            print(f"目录不存在: {dir_name}")
    
    # 处理其他未列出的顶级目录
    for item in root_path.iterdir():
        if (item.is_dir() and 
            not should_skip_directory(item.name) and 
            item.name not in main_directories):
            
            print(f"处理额外目录: {item.name}")
            add_directory_section(item, summary_content, 0)
            summary_content.append("")
    
    # 移除末尾多余的空行
    while summary_content and summary_content[-1] == "":
        summary_content.pop()
    
    # 写入文件
    try:
        with open('SUMMARY.md', 'w', encoding='utf-8', newline='\n') as f:
            f.write('\n'.join(summary_content))
        print("=> `SUMMARY.md` generate done!")
    except Exception as e:
        print(f"写入SUMMARY.md失败: {e}")

if __name__ == "__main__":
    generate_summary()

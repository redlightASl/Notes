本博文参考胡伟武《计算机体系结构基础》、P-H《计算机组成与设计-硬件/软件接口（RISC-V版）》和Bryant《深入理解计算机系统》写作。笔者系初学，如有错误敬请指正。

# 计算机体系结构笔记1【指令集】

根据指令长度不同，指令集可以分为

* 复杂指令集**CISC**（Complex Instruction Set Computer）：指令长度可变，cpu执行时将其翻译成一条或多条微代码
* 精简指令集**RISC**（Reduced Instruction Set Computer）：指令长度相对固定
* 超长指令字**VLIW**（Very Long Instruction Word）：多条同时执行的指令的集合

早期计算机为了提高执行速度，降低软件和编译器的设计，都采用CISC架构，随着加入的指令越来越多，硬件复杂度逐渐提高CISC开始出现一系列问题，大量指令闲置，微代码翻译也增加了流水线设计的难度，降低频繁使用的简单指令的执行效率。后来IBM 801、MIPS、ARM等架构的实现带来了RISC的成功应用，它指令功能简单，单个指令执行周期短；使用定长指令，便于译码，通过load-store简单指令访存，有利于是西安高校的流水线、多发射技术，可以很好提高主频和效率。发展到现代，CISC和RISC已经进行很大程度融合，x86的CISC指令会被翻译成微代码后对微代码使用超流水、乱序执行、多发射等RISC常用的实现。RISC-V中则支持了扩展指令来完成高性能处理需求。VLIW起源于20世纪80年代，是指令级并行思想的发展，一个超长指令字由多个不相关的指令组成，从而方便并行处理，但是大大增加了编译器的实现难度，当前应用不广。

**ISA**即**指令集体系结构**，提供了三个基本功能：

* **提供硬件和软件之间的约定**，也就是起到了软件/硬件隔离的作用，这将机器（处理器）和软件分离开

    ISA以下的部分就是计算机硬件，包括处理器的具体实现；以上的部分则是软件，包括用于驱动处理器的操作系统和用于生产软件的编译器

* **作为微处理器设计的规范**，也就是起到了软件/硬件接口的作用，这将处理器执行程序和软件开发联系起来

    比如x86的cpu就必须实现x86指令集里面规定的各个基础指令，否则为x86开发的软件就没办法跑在它上面，rv32i的cpu就必须实现risc-v规定的i指令子集里面所有指令才能让gcc编译出的risc-v程序跑在它上面

* **实现动态-静态接口**（**DSI**，Dynamic-Static Interface），也就是区分哪些任务是基于软件和编译器静态优化的，哪些任务是通过cpu设计和外围硬件进行动态完成的。

    比如比较直观的概念就是分支预测器，它将原来需要软件优化才能使用的分支跳转预测变成了一个由硬件实现的功能，这样编译器的开发者就不需要再操心该怎么帮助上层开发者优化if和while了，这些东西都会由硬件帮助完成

![image-20221202145250078](计算机体系结构笔记1【指令集】.assets/image-20221202145250078.png)

ISA设计中最关键的问题之一就是DSI的位置，这个位置决定了高级语言编写的应用程序与底层机器实际硬件处在哪种抽象层次。DSI之上的任务可以通过优化编译器或者程序来提高性能，DSI之下的任务则需要使用特定的微体系结构和硬件设计来提高性能。

## 设计指令集的原则

现代RISC指令集一般遵循下面三大设计准则

* **简单源于规整**

    等长的规整指令方便硬件译码（Decode），硬件设计者可以将宝贵的硅面积用于更能提升处理器性能的地方。同时对于上层的软件开发者（尤其是编译器开发者），简单的指令更方便处理，复杂的功能可以被拆分成许多简单功能，从而加速开发流

* **更少即更快**

    精简指令集的指令数很少，这就导致需要多条指令才能完成一个复杂任务；反过来说，更少的指令方便处理器执行（Execute），从而大大提高流水线/超标量处理器的运行频率，让处理器能够适应更多场合——低功耗场合下只需要减少流水线长度、降低频率，高性能场合下也只要提高频率、加长流水线和加入超标量执行硬件

    对于寄存器来说也是这样：更多的寄存器会增加扇出和负载电容，拖慢CPU执行频率

* **优秀设计需要适当折中**

    为了实现上面的两条准则，往往需要对指令的设计进行折中，牺牲一部分规整性保全指令数，抑或是牺牲一部分指令性能来让指令格式更加规则

这三条准则也正是ARM指令集一直在完善的目标和RISC-V指令集设计的初衷

## 操作数

计算机的用途就是处理数据——即使现代计算机能够运行大型工业软件、多媒体应用、各种游戏，这也无法否认所有这些都是数据的“变体”。冯氏计算机中的数据会被保存在内存，等待需要的时候被拿出来送到ALU中计算；实际的CPU中，保存数据的是**寄存器**。

所有数据和指令都以同样的二进制方式存储在内存（这里先不考虑存储层次结构）中，CPU通过指令计数器PC获取对应内存地址的数据，按照ISA规定的译码方式将其分成两个部分：**操作数**，就是要被处理的数据；以及**指令**，也就是处理操作数的方式。

更抽象地讲，**CPU就是一个复杂的大状态机**：这个状态机做的唯一一件事就是根据PC取出内存中的数据，按部就班译码、执行，最后把得到的结果写回到内存中，循环往复。在这套循环中，状态机可能会根据译码的结果对数据运算，暂存某些数据，或者把PC的值进行改变，甚至修改自身的运行状态（ARM中的CSR寄存器用于控制CPU的各种运行状态）。不管怎样，**指令和操作数是CPU运行的根本**

ISA规定了指令长什么样子，而操作数则按照IEEE的规定进行标准化存储。

指令中的算术*运算*只作用于CPU内部的寄存器，而在运算前需要先*加载*（load）操作数，完成运算后还要把操作数写回（write-back）寄存器或保存（store）到内存

这一节中主要记述操作数的分类和格式——虽然不同指令集总会有处理操作数的不同方法和思路，但是操作数本身是不会改变的。具体的指令集会在后面附录中介绍

### 基地址和偏移地址

内存通常以数组的形式描述

```verilog
reg [31:0] memory [0:255];
```

这行代码就描述了一个具有256个存储单元，每个单元能够存储32位数据的内存。在内存中，常使用一串数来表示地址，处理器可以使用某个指令直接访问该地址。这种寻址（Addressing）方式称为**直接寻址**。

32位的CPU具有32位的PC，因此可以寻址的范围是`0~2^32`，也就是4GB，我们很希望有这样一条指令，能够向计算机中输入32位的地址（**立即数寻址**），这样CPU寻址时PC就能够直接跳转到想要的地址。很可惜，这样的指令会很长——至少32位。于是我们可以考虑使用这样一种方法：预先从内存把某个地址加载到寄存器，再使用某条指令，读取保存地址的寄存器，同时修改目标为保存的地址，这样就可以用更短的指令完成任务。

在C语言中我们还经常遇到处理数组的场景，例如

```c
a = A[2];
```

我们一般使用**间接寻址**来处理这样的场景：假设数组A保存在一个内存地址`P`，可以使用一条指令，取出地址`P`同时传入一个数`2`，计算出`P+2`地址的值，让CPU把这个地址中的数据取出，保存到变量a中。在这个例子里，`P`被称为**基地址**，`2`被称为**偏移地址**或**偏移量**

### 立即数

上面我们提到了有这样一条指令：他指出了地址`P`，同时向CPU中传入一个数`2`，这个随指令被传入CPU的数被称为**立即数**（immediate）

CPU是很傻的东西，它不知道内存里的数据是什么，有什么用——它只能按照编写好的译码逻辑，按ISA规定的格式拆分PC指向内存单元里的数据。ISA中会专门规定各种各样的字段，有专门用于指出当前指令用途的`magic number`或者说`opcode`（这一部分会在后续CPU译码环节介绍）；有所谓的“**源操作数**”（src），也就是从哪里获得要用的数据；有“**目标操作数**”（dest），即要把执行指令以后的结果保存到哪里；还可能有一个字段专门保存**立即数**，这就是一个二进制数，长度按照ISA规定

立即数可能是一个基地址、偏移地址或者直接寻址地址，也可能就是一个单纯的数，用来加到某个源操作数上（比如指令`ADDI DEST SRC #1`就表示把SRC寄存器中的值+1后存到DEST寄存器里）。*它的用途要看ISA怎么规定*

## 地址空间

指令集会对处理器能够访问的地址空间范围加以限制。处理器可访问的地址空间包括寄存器空间和系统内存空间，二者是物理隔离的。寄存器空间需要使用*编码到指令中的寄存器号*访问，内存空间则通过*访存指令*访问

寄存器空间包括通用寄存器、特殊寄存器和控制寄存器，CPU在运算过程中实时调用这些寄存器，访问延迟是最小的。

内存空间是指CPU访存指令能访问到的内存地址，一般会被分成多个区域，一些区域是物理内存映射而来的地址，另一些区域是由系统总线映射而来的外部设备IO寄存器组成的地址。不同的区域所使用的访存指令可能有所不同

> 一般来说MIPS、ARM、RISC-V、LoognArch这些RISC指令集不区分访存指令，而x86会使用in/out指令来访问外设IO，使用标准load/store指令访问物理内存。但很多单片机中的外设寄存器会被映射到CPU内存空间，访问这些寄存器时常常不能按字节读写而需要按位读写，这就需要用到特殊的按位读写指令（如果指令集提供的话）；而单片机访问紧耦合存储器只使用指令集规定的标准访存指令即可。这也是非实时CPU和实时CPU

根据指令使用数据的方式，指令集可以分成

* **堆栈型**：又称零地址指令。以栈顶数据作为默认操作数，对栈顶数据进行运算并将结果压栈
* **累加器型**：常称为单地址指令，包含一个隐含的累加器操作数，指令中的操作数与隐含操作数运算后将结果写回累加器中
* **寄存器-存储器型**：每个操作数都由指令显式指定，操作数混杂寄存器和内存地址
* **寄存器-寄存器型**：每个操作数都由指令显式指定，操作数只能是存储器，但访存指令允许使用内存地址立即数作为传入的操作数

寄存器-存储器和寄存器-寄存器型的区别就是寄存器-寄存器型指令集中的操作数只能来自于寄存器，即使访存指令也只是通过指令传入立即数，再根据立即数对内存寻址，这个过程需要通过load/store指令来完成

目前除了x86指令集还保留着早期计算机常用的堆栈型和累加器型指令外，主流的指令集已经全部采用寄存器-寄存器型。因为寄存器的访问速度快，可以充分利用局部性原理，又可以较好地解决相关性问题，从而实现流水线和超标量细节

## 附录：具体指令集介绍

### ARM CM0指令集

这一部分是ARM CM0指令集的介绍。读者可以参考《Cortex-M0解读》系列博文，这里暂且省略

### RISC-V指令集

这一部分是RV32IM指令集的介绍。读者可以参考《RISC-V学习笔记》和《RISC-V使用笔记》系列博文，这里暂且省略

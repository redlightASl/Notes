# 使用C语言进行PC程序开发

因为本人不是专业的软件佬，对PC程序开发不能说知之甚少，只能说一窍不通，这里只能用刚学来的软件工程思路结合浅薄的C/C++知识大致描述一下进行上位机开发的流程

> 不要小看C++啊！

## C/C++进行图形界面开发

部分嵌入式设备需要一个运行在PC上的上位机作为主控，尤其是各种机器人总是需要一个控制平台。而有些嵌入式设备本身就运行着Linux或者其他的一些能跑java、python甚至各种其他很吃资源的高级语言的操作系统。我们往往采用“主从主控”的架构，也就是一个跑着Linux的设备负责处理高性能需求和面向用户的应用，通过UART、IIC/SMBUS、SPI等片上总线与一个跑着RTOS或者裸机应用的MCU通信，这个MCU负责处理面向设备的高实时性应用。

在这些情况下，我们往往依赖于C/C++进行图形界面开发——GNU/Linux生态基于GNU，而GNU和其他开源/自由软件的C库是我们能最快速获得的依赖。

> 如果在Linux下编译一个“先进的”程序，比如一个基于Web前后端技术的桌面应用——我需要node、java环境，要知道嵌入式设备上面很难找到包管理器，因此往往需要用另一套交叉编译器在PC把开发环境编译出来，那么还需要再安装一套开发环境，这中间的调试、编译会相当耗时，因此除了安卓/OpenWrt这种有成熟生态和包管理器（opkg也勉强能算，虽然并不智能）的系统能节约时间，其他嵌入式Linux上做应用会很折磨。如果直接用C的话就会好很多，至少上位机并不需要和其他语言打交道，各种lib基本都能简单编译出来，而且在busybox、yocto这些“造linux”的工具上我们还能直接把库编译出来提前存到嵌入式设备里，免去到时候转移文件的折磨

当前Linux下做图形界面最新最潮的包就是Qt了，下面优先介绍一下Linux下的Qt程序开发

> 读者应当初步了解C++和面向对象编程（不是之前提到过的C面向对象，而是C++的三大法宝）

### Qt







### PyQt

PyQt是Qt在Python上的实现——但是您猜怎么着，怹底层调用的全是C++代码，盖了帽了！

只能说PyQt让Qt的含金量直接++，虽然有一些bug而且效率略低，但是学了Python就能用，适合用于实现某些简单的工具

拿它当可视化脚本工具也不错（笑）

### C#

准确的说这个东西不算C/C++，他是微软基于C/C++开发的用于Windows图形界面编程的语言

我不懂，不做介绍（笑）

嵌入式是Linux的天下，什么时候轮到微软撒野.jpg

## 版本控制工具

版本控制系统，往往以英文缩写为RCS，其目的是保存一个项目在开发过程中的众多版本的代码快照或开发过程中的阶段

版本控制系统主要提供三种基础功能

* 为文件系统提供一个时间维度——**记录**
* 记录项目的不同版本——**分支**
* 将源代码有序保存以备使用——**管理**
* 方便地融合不同分支——**分布式**

### diff工具

最简单的版本控制工具就是diff和patch

这两个工具隶属于POSIX标准，使用以下命令就可以显示出文件之间被改动的几行

```shell
diff docA docB
```

使用管道将输出导入文本文件，即可从文本编辑器中读取到经过高亮的版本

```shell
diff docA docB > history.txt
```

输出中使用+和-标记出了增加或被移除的某些行，可以使用-u参数得到在增加/删减周围的几行内容

导出的文本文件称为**改变列表**

使用patch工具可以读取diff文件并执行改变列表

```shell
patch < history.txt
```

上面的命令可以通过已有的改变列表应用改动到一份之前的代码

如果已经删除了老版本的文件，可以使用以下命令将后一个版本的文件回退到前一个版本，这个过程称为**回滚**

```shell
patch -R < history.txt
```

这两个工具很原始，所以现在没什么用了，但他们的版本控制思想正是Git诞生的源泉

### Git工具

Git是一个C程序，基于一组*对象*提供服务

Git中最基础的是**提交**对象（commit），这个对象类似diff，可以将当前目录下所有代码信息打包

提交对象连接起来形成了一个*树*，每个提交对象有且至少有一个父提交对象，在Git中的版本切换就是在上下遍历提交对象树

### Git工具的使用

1. 创建新的版本库

   ```shell
   git init
   ```

   使用上面的命令创建一个.git目录，并将有关该版本库的所有信息保存在这个目录下

   注意：**.git目录是Git工具实现功能的最重要依托，如果删除了当前目录下的.git目录，git工具所有的历史记录就失效了**

   如果想删除一个版本库，只要

   ```shell
   rm -rf .git
   ```

   如此简单！

2. 从网络获取源代码

   ```shell
   git clone https://gitee.com/redlightasl/notes.git
   ```

   使用上面的代码可以从远程的代码库复制代码到本机

   也可以用类似的方式克隆一个本机上位于其他目录的工程

3. 产生差异并提交

   使用

   ```shell
   git add balabala
   ```

   来存储当前工程文件中发生变化的部分

   可以直观理解成这个指令保存当前工程文件的快照

   如果想要保存所有文件，使用

   ```shell
   git add .
   ```

   即可将所有文件加入一个称为**Index**的变化列表，这个变化列表记录了当前所发生的文件和内容变更

   同时也有如下命令

   ```shell
   git rm file
   git mv a_file another_file
   ```

   含义简洁明了，任何知道linux shell怎么用的人都能快速上手

   在产生差异后就能生成提交了：

   ```shell
   git commit -m "a new commit"
   ```

   这是一个标准的提交指令格式

   -m参数后面跟要在提交中附加的注释说明

   运行

   ```shell
   git log
   ```

   可以查看这些注释消息

   如果你忘记加上这个参数，Git工具会使用环境变量${EDITOR}指示的文本编辑器（在windows下会打开git自带bash shell里面的vi），用户可以自行输入消息

   如果在提交前不想使用git add，可以在commit后面加参数-a，这样就可以省去add了

4. 查看提交对象的内容

   Git工具中将提交的所有数据称为元数据

   最关键的元数据就是提交对象的名字，Git为每份提交都生成了一个独一无二的SHA1编码，在提交后可以看到提交对象的哈希数值的前几个数字，可以运行

   ```shell
   git log
   ```

   来查看当前提交对象的历史提交对象列表

   如果想要查看版本号为**abcde后面省略**的代码，可以直接使用指令

   ```shell
   git checkout abcde
   ```

   也就是后接哈希码的前5个字符（一般这么多字符足够区分两个不同的版本，如果发现不行那就再多往后写几位）

   这样可以将项目重置为这个版本

   在查看完以后，可以使用

   ```shell
   git checkout master
   ```

   来恢复到最新状态

   master是Git工具中的一个指向主要版本的指针

   类似的还存在HEAD指针，它永远指向最新的一份提交

5. 查看更改

   使用

   ```shell
   git diff > diffs.txt
   ```

   来将当前的文件更改输出到文件中，Git可以精确到多个提交的比较

   ```shell
   git diff 234sd 65sf2 
   ```

   同时为了避免使用繁杂的十六进制哈希值，Git工具为提交的tag做出了更多简化

   HEAD代表目前最后一个提交

   ~1代表当前提交的父提交

   ~2代表当前提交的祖父提交

   以此类推

### Git版本树结构

版本库中有一个树状结构，不仅可以通过提交实现版本回滚，还可以通过树的分支（fork）实现功能并行和分支代码

在树状结构中，称最长的分支为主分支

习惯上，一般保持主分支随时拥有完整的功能，实验性的功能或特性可以通过创建新分支来修改

使用

```shell
git branch newbranch
git checkout newbranch
```

来创建并切换到新分支

使用

```shell
git branch
```

来查询当前工作在哪个分支

使用

```shell
git branch -m new_branch_name
```

来命名一个分支

当某一分支功能完成时，可以通过

```shell
git checkout master #切换到主分支
git merge newbranch #融合之前的分支
```

来实现功能融合

特别地，如果两个分支派生后又各自存在一定变化，merge就会受阻

这时候需要使用

```shell
git status
```

来检查未融合的文件列表，一个一个文件修改、add、提交，并手工将其合并进主分支

### 远程版本库

如果你的版本库存在一个远程的列标，指向与这个库有关的存放在别处的版本库，那么可以使用git clone获得远程版本库

通过以下指令方便地在远程库和本地库之间得到同步

```shell
git pull xxx #从远程版本库中拉取远程变化
git push xxx #将本地的变化推送到远程版本库
```

这两个指令是最常用的版本控制指令，可以实现在github和本地之间同步代码

特别地，如果本地代码和从远程库中拉取的代码存在不同，需要使用git merge指令加以融合

### Git Submodule

如果当前项目中用到第三方库，或者项目由很多不同的组件拼接而成，可以考虑以下三种方法：

* 直接将所有源码复制到工程目录
* 在README文档或源码注释中给出相关信息
* 使用submodule

git提供了一个类似包管理器的工具：**git submodule**

使用以下指令将一个第三方库添加到工程目录

```shell
git submodule add <第三方库地址>
git add .
git commit -m "已添加第三方库"
```

使用完以上指令后，当前目录就会多出一个`.gitmodules`的文件，同时会在当前位置引入一个快捷方式，直接链接到第三方库的地址——**当前版本库是不会存储来自第三方库的文件的**，`.gitmodules`保存了第三方库的快捷方式，不过其他人clone的时候需要完整的文件，这时候可以采用两种方式下载文件

* 在clone父目录时使用

    ```shell
    git clone <url> --init --recursive 
    ```

    直接将submodule复制下来

* 在已经clone过的父目录中使用

    ```shell
    git submodule update --remote --force
    ```

    来强制性更新子模块

### VSCode的Git可视化插件

VSCode中可以添加很多用于可视化Git的方便的插件，比较好用的有以下几个

1. Git Blame

   可以直接在状态栏里看到某条代码的编写人和提交时间

   可以点击状态栏看到具体的commit hash码

2. Git File History

   具有很炫酷的界面，可以以滚动条的方式即时展示文件中代码随commit的变化

3. Git Graph

   可视化版本分支Branch，同样有很漂亮的界面

4. Git History

   进入一个git目录就可以应用这个插件的配置，然后查看从最早到现在目录里面的commit版本变化，并以侧边栏的形式展示两个选中版本文件的不同

5. GitHub

   就是可以直接在VSCode上登录GitHub完成同步之类的操作，还能用来看Github上的代码，如果有一个强悍的网络条件还是很推荐的

6. GitHub Pull Requests and Issues

   件如其名，就是用来Pull Requests的

7. **GitLens**

   很强大的Git插件，实时回滚、对比版本差异、在commit中跳转、切换分支......这个插件基本上算是上面所有插件的爹，该有的功能都有，无非就是不能可视化，如果对于装b没有太大需求，只要装这个插件配合上面的GitHub插件就足够了

### 使用Git工具和Gitlab进行分布式项目管理

**Gitlab**是一个基于git的在线代码仓库软件，可以在企业、学校等内网中搭建一个类似Github的网站，这种网站可以统称为**Git托管平台**

一般来说个人开发不需要独立搭建Gitlab，只要使用Github（或Gitee）即可，二者的使用流程都是类似的。

> 这里默认用户都**在Git托管平台上建立了账号**，并且**将自己的账号和本地git工具通过ssh关联**

原始项目的开发者会先创建一个原始的项目仓库**Repository**（简称repo），并将部分源文件push到托管平台，随后其他开发者就能通过**fork**这个repo到自己的远程平台

原始repo一般称为主分支（**master**），其他开发者通过fork这个repo将代码复制一份到属于自己的远程平台，随后在自己的repo上进行的所有修改都不会影响master。

开发者只需要使用`git clone <项目git地址>`就可以把远程repo上的文件复制到本地，之后在本地对代码进行修改。

首先要创建一个分支**Branch**

```shell
git branch <分支名> #创建分支
git checkout <分支名> #切换到分支

git checkout -b <分支名>#创建并切换到分支
```

然后在该分支下进行修改。开发自测结束后，将修改提交至本地仓库，使用以下代码

```shell
git add .
git commit -m "增加的功能或进行的修改"
```

在提交之前需要先检查之前的版本是否有改动

因为分布式项目中并不是一个人在独立开发，而是多个人同时并行开发，如果在我们之前另外一个开发人员进行过提交并且与master合并了，那么我们的项目并不是最新的，提交的时候会导致错误，严重情况下会导致部分开发进度被重置

使用以下代码进行检查

```shell
git remote add upstream <主仓库git地址> #关联master仓库到本地仓库
git pull upstream master --rebase #从master仓库拉取更改到本地仓库
```

如果没有其他改动，那就不需要更多操作，直接上传即可；但是如果出现了改动，就需要在本地手动解决冲突，在冲突的代码中选择一个合适的版本

这个过程比较令人烦躁，如果使用上面介绍过的可视化工具进行代码版本对比会好很多

修改完毕后可以使用以下代码保存

```shell
git add . #保存修改
git rebase --continue #将新的修改合并到当前分支
```

使用`git push origin <分支名>`进行上传。这样本地的代码修改就结束了

随后在托管平台上向主repo发起**Merge Request**，等待原始项目的开发者或其他审核人员进行审查即可，审查完毕的代码会被自动加入主repo的<分支名>新分支，还不能加入主分支

特别地，如果审核人员提出修改，使用以下代码重新进行上传

```shell
git add .
git commit --amend --no-edit #合并本次commit和上次commit，但只保留一个commit记录
git pull upstream master --rebase
git push origin <分支名> -f #强制合并
```

想要将代码加入主分支master，最后要将本地代码与最新的master代码进行同步

```shell
git pull upstream master --rebase #更新本地代码
git push origin master #推送到origin的master主分支
```

这样一次分布式开发就完成了。所有开发者都可以遵循这样的流程进行协同开发